{"pageProps":{"title":"Livewire Datatables","language":"php","tags":["laravel","livewire"],"content":"<p>Who didn&#39;t need a table to show some data in a Laravel application at some point? I came a cross this recently while building a ticketing system. I was using Livewire, a cool new layer to make dynamics blade components without writing API. I will show you what I did.</p>\n<p>Let&#39;s get started. We create the component with the artisan command line tool. </p>\n<pre><code class=\"language-bash\">php artisan livewire:make UserTable</code></pre>\n<p>The genereted component is something like this.</p>\n<pre><code class=\"language-php\">namespace App\\Http\\Livewire;\n\nuse App\\Models\\User;\nuse Livewire\\Component;\n\nclass UserTable extends Component\n{\n    public function render()\n    {\n        return view(&#39;livewire.user-table&#39;);\n    }\n}</code></pre>\n<p>Next we can add two custom properties like so. The <code>columns</code> property is an array that we will use to create the table headers in the HTML. I&#39;ll cover later what the <code>Column</code> class is. The <code>rows</code> property is the query to use to get the data we want. I like this approach as we can write any kind of query in here and can be tuned for this specific component.</p>\n<pre><code class=\"language-php\">public function getColumnsProperty()\n{\n    return [\n        Column::text(&#39;Name&#39;),\n        Column::text(&#39;Email&#39;),\n        Column::text(&#39;CreatedAt&#39;),\n    ];\n}\n\npublic function getRowsProperty()\n{\n    $query = Ticket::query();\n\n    $query-&gt;latest();\n\n    return $query-&gt;paginate();\n}</code></pre>\n<p>The column class is a very simple one. It&#39;s basically a fancy array with some usefull methods. I snake cased the title to create the key that will be used to get the property on the eloquent model. Calling a key like a function will set the value. So for example if we need a custom key not based on the title you can do <code>$column-&gt;key(&#39;custom_key&#39;)</code></p>\n<pre><code class=\"language-php\">use Illuminate\\Support\\Str;\n\nclass Column\n{\n    protected array $options = [\n        &#39;format&#39; =&gt; &#39;string&#39;, // default column type\n    ];\n\n    public function __construct(string $title)\n    {\n        $this-&gt;options[&#39;title&#39;] = $title;\n        $this-&gt;options[&#39;key&#39;] = Str::snake($title);\n    }\n\n    public static function text(string $title)\n    {\n        return new static($title);\n    }\n\n    public function __call( $name, $arguments )\n    {\n        return tap($this, function($col) use ($name, $arguments) {\n            $col-&gt;options[$name] = $arguments[0];\n        });\n    }\n\n    public function __get( $name )\n    {\n        return $this-&gt;options[$name] ?? null;\n    }\n}</code></pre>\n<p>I wanted to use dot notation like <code>details.address</code> to get the value of the eloquent model so that I could reach relations on the model. To achive this I added a simple trait to the model.</p>\n<pre><code>trait CanHaveDataTable\n{\n    public function getValueFor(Column $column): ?string\n    {\n        $data = $this-&gt;toArray();\n\n        return collect([$data])-&gt;pluck($column-&gt;key)-&gt;first();\n    }\n}</code></pre>\n<p>If you are familiar with the <code>pluck</code> function you can easly guess what I did. The <code>pluck</code> function can access values with the dot notation. So I converted the model (<code>$this</code>) to an array and wrapped it with an array and instantiated a <code>Collection</code> with the <code>collect</code> function.</p>\n<p>Finally we can kick in some table templates in the blade file of the Livewire component. Here we have the two special custom properties. So all we need to do is iterate on those properties. I will use tailwind the get things pretty.</p>\n<pre><code class=\"language-html\">&lt;table class=&quot;table min-w-full border-collapse divide-y divide-gray-200 bg-white&quot;&gt;\n&lt;thead&gt;\n    &lt;tr&gt;\n        @foreach ($columns as $column)\n            &lt;th&gt;{{$column-&gt;title}}&lt;/th&gt;\n        @endforeach\n    &lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n    @forelse ($rows as $row)\n        &lt;tr&gt;\n            @foreach ($columns as $column)\n                &lt;td&gt;\n                    {{$row-&gt;getValueFor($column)}}\n                &lt;/td&gt;\n            @endforeach\n        &lt;/tr&gt;\n    @empty\n        &lt;tr&gt;\n            &lt;td colspan=&quot;{{count($columns)}}&quot; class=&quot;text-gray-500&quot;&gt;\n                {{ __(&#39;No records.&#39;)}}\n            &lt;/td&gt;\n        &lt;/tr&gt;\n    @endforelse\n&lt;/tbody&gt;\n&lt;/table&gt;</code></pre>\n<p>And of course, if you called paginate on the query you can this snippet to have the links to paginate the table. Althogh, doing this way we will not use the dynamic feature of livewire because we would click another link and refresh the page. You can read the livewire documentation on &quot;Using A Custom Pagination View&quot;, but the idea is to have custom links that will set the page.</p>\n<pre><code class=\"language-html\">&lt;div class=&quot;mt-5&quot;&gt;\n    {{ $rows-&gt;links() }}\n&lt;/div&gt;</code></pre>\n<p>But if you implement a little search input that will be dynamic and will use all the power of Livewire. We can edit the rows custom property like so. </p>\n<pre><code>public function getRowsProperty()\n{\n    $query = User::query();\n\n    if ($this-&gt;search) {\n        $query = $query-&gt;search($this-&gt;search);\n    }\n\n    return $query-&gt;paginate();\n}</code></pre>\n<p>Hope you enjoy this little component I did. Send me your approach or how will you improve this. \nYou can found me on <a href=\"https://twitter.com/giorgiopogliani\">Twitter</a> or <a href=\"https://instagram.com/giorgiopogliani\">Instagram</a></p>\n"},"__N_SSG":true}